#pragma kernel Density

#include "Common.hlsl"

RWStructuredBuffer<float4> points;
float3 voxelsPerAxis;
float3 worldMin;
float3 worldMax;
float3 chunkSize;
float3 chunkCenter;
float voxelSize;

float time;
float3 radius;
float noiseScale;
float noiseWeight;

// Simple noise function
float hash31(float3 p) {
    p = frac(p * 0.3183099 + 0.1);
    p *= 17.0;
    return frac(p.x * p.y * p.z * (p.x + p.y + p.z));
}

float noise(float3 p) {
    float3 i = floor(p);
    float3 f = frac(p);

    float3 u = f * f * (3.0 - 2.0 * f);

    return lerp(
    lerp(lerp(hash31(i + float3(0, 0, 0)), hash31(i + float3(1, 0, 0)), u.x),
    lerp(hash31(i + float3(0, 1, 0)), hash31(i + float3(1, 1, 0)), u.x), u.y),
    lerp(lerp(hash31(i + float3(0, 0, 1)), hash31(i + float3(1, 0, 1)), u.x),
    lerp(hash31(i + float3(0, 1, 1)), hash31(i + float3(1, 1, 1)), u.x), u.y), u.z);
}

[numthreads(blockSize, blockSize, blockSize)]
void Density (int3 id : SV_DispatchThreadID)
{
    if (id.x >= voxelsPerAxis[0] || id.y >= voxelsPerAxis[1] || id.z >= voxelsPerAxis[2]) {
        return;
    }

    // Calculate world position of this voxel
    // This calculates position relative to chunk bounds, not centered at chunkCenter
    float3 pos = worldMin + (id / voxelsPerAxis) * (worldMax - worldMin);

    // Compute delta from chunk center
    float3 delta = pos - chunkCenter;
    // Calculate cylinder falloff in xy-plane using radius.x and radius.y
    float2 dxy = delta.xy / float2(radius.x, radius.y);
    float cylinder = 1.0 - saturate(length(dxy));
    
    if (abs(delta.z) >= radius.z - (0.001f))
    {
        cylinder = 0.0;
    }

    float n = noise(pos * noiseScale);
    float density = cylinder + noiseWeight * (n - 0.5); // remap to [-0.5, 0.5]
    density = saturate(density);

    int index = indexFromCoord(id.x, id.y, id.z, voxelsPerAxis);
    points[index] = float4(pos, density);
}
