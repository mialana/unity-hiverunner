// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Density

#include "Common.hlsl"

static const int blockSize = 8;

RWStructuredBuffer<float4> points;
float3 voxelsPerAxis;
float3 worldMin;
float3 worldMax;
float3 chunkSize;
float3 chunkCenter;
float voxelSize;

float time;

[numthreads(blockSize, blockSize, blockSize)]
void Density (int3 id : SV_DispatchThreadID)
{
    if (id.x >= voxelsPerAxis[0] || id.y >= voxelsPerAxis[1] || id.z >= voxelsPerAxis[2]) {
        return;
    }

    float3 pos = chunkCenter + id * voxelSize - chunkSize / 2;
    pos = min(worldMax, pos);

    // Gradually oscillate the height of the honey over time
    float heightFactor = time * 0.05f; // Oscillates between -0.5 and 0.5 every 10 seconds

    float finalVal = (1.f - (pos.y - (chunkCenter.y - chunkSize.y / 2)) / chunkSize.y);
    // finalVal += heightFactor;

    // Add sinusoidal noise based on position
    float noise = sin(pos.x * 0.5f + time * 0.2f) * sin(pos.z * 0.7f + time * 0.3f) * 0.07f;

    finalVal += noise;

    // Explicitly set density to zero near x and z walls
    // float threshold = 0.5f; // Distance threshold from walls
    // if (abs(pos.x - worldMin.x) < threshold || abs(pos.x - worldMax.x) < threshold ||
    // abs(pos.z - worldMin.z) < threshold || abs(pos.z - worldMax.z) < threshold)
    // {
    //     finalVal = 0.0f;
    // }

    // Clamp the final value to ensure it stays within a valid range
    finalVal = clamp(finalVal, 0.f, 1.f);

    int index = indexFromCoord(id.x, id.y, id.z, voxelsPerAxis);
    points[index] = float4(pos, finalVal);
}
