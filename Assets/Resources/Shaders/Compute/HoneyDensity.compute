// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Density

#include "Common.hlsl"

RWStructuredBuffer<float4> points;
float3 voxelsPerAxis;
float3 worldMin;
float3 worldMax;
float3 chunkSize;
float3 chunkCenter;
float voxelSize;

float time;
float honeyHeight;

float hash31(float3 p) {
    p = frac(p * 0.3183099 + 0.1);
    p *= 17.0;
    return frac(p.x * p.y * p.z * (p.x + p.y + p.z));
}

float noise(float3 p) {
    float3 i = floor(p);
    float3 f = frac(p);

    // trilinear interpolation
    float n000 = hash31(i + float3(0, 0, 0));
    float n100 = hash31(i + float3(1, 0, 0));
    float n010 = hash31(i + float3(0, 1, 0));
    float n110 = hash31(i + float3(1, 1, 0));
    float n001 = hash31(i + float3(0, 0, 1));
    float n101 = hash31(i + float3(1, 0, 1));
    float n011 = hash31(i + float3(0, 1, 1));
    float n111 = hash31(i + float3(1, 1, 1));

    float3 u = f * f * (3.0 - 2.0 * f);

    return lerp(
    lerp(lerp(n000, n100, u.x), lerp(n010, n110, u.x), u.y),
    lerp(lerp(n001, n101, u.x), lerp(n011, n111, u.x), u.y),
    u.z);
}

float ridge(float n) {
    n = abs(n); // fold
    n = 1.0 - n; // invert
    return n * n; // sharpen ridges
}

float ridgedMF(float3 p) {
    float sum = 0.0;
    float freq = 0.5;
    float amp = 0.5;
    float prev = 1.0;

    for (int i = 0; i < 3; i ++) { // ~5 octaves
        float n = noise(p * freq);
        float r = ridge(n);

        sum += r * amp * prev;

        prev = r;
        freq *= 2.0;
        amp *= 0.5;
    }
    return sum;
}


[numthreads(blockSize, blockSize, blockSize)]
void Density (int3 id : SV_DispatchThreadID)
{
    if (id.x >= voxelsPerAxis[0] || id.y >= voxelsPerAxis[1] || id.z >= voxelsPerAxis[2]) {
        return;
    }

    float3 pos = chunkCenter + id * voxelSize - chunkSize / 2;

    float heightDelta = honeyHeight - pos.y;

    // 'falloff' controls surface thickness (bigger = softer)
    float falloff = 15.0f; // tweak as needed
    float baseVal = saturate(0.5f + heightDelta / falloff);

    float finalVal = baseVal;

    // sinusoidal noise
    float ripple = sin(pos.x * 0.5f + time * 0.5f) *
                   sin(pos.z * 0.7f + time * 0.5f);
    finalVal += ripple * 0.1f;

    // ridged noise
    float ridged = ridgedMF((pos - 0.1f) + time * 0.1f);
    finalVal += ridged * 0.4f;

    // Clamp to valid range
    finalVal = clamp(finalVal, 0.0f, 1.0f);

    // Write to index
    int index = indexFromCoord(id.x, id.y, id.z, voxelsPerAxis);
    points[index] = float4(pos, finalVal);
}
